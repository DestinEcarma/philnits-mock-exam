[
  {
    "id": "2019S_FE_AM_1",
    "question": "For logical variables *p* and *q*, which of the following is a logical expression that evaluates to true for any values *p* and *q*?",
    "options": [
      "$\\overline{p} + (p \\cdot q)$",
      "$(p \\cdot q) + (\\overline{p} + (p \\cdot \\overline{q}))$",
      "$(p \\cdot \\overline{q}) \\cdot (\\overline{p} + q)$",
      "$((\\overline{p}\\cdot q)\\cdot(p \\cdot q))\\cdot\\overline{q}$"
    ],
    "correctAnswer": 1,
    "solution": "### We can evaluate if logical expressions will always be true(1) by simplifying them.\n\n### Simplifying $\\overline{p} + (p \\cdot q)$\n1. $\\overline{p} + (p \\cdot q)=(\\overline{p}+p)\\cdot(\\overline{p}+q)$     by distributive law\n2. $\\overline{p}+p=1$                                   by inverse law\n3. $1\\cdot(\\overline{p}+q)=(\\overline{p}+q)$                   by identity law\n\n### Simplifying $(p \\cdot q) + (\\overline{p} + (p \\cdot \\overline{q}))$\n1. $\\overline{p} + (p \\cdot \\overline{q})=(\\overline{p}+p)\\cdot(\\overline{p}+\\overline{q})$     by distributive law\n2. $(\\overline{p}+p) = 1$                                by inverse law\n3. $1+(\\overline{p}+\\overline{q})=\\overline{p}+\\overline{q}$                    by identity law\n4. $(p\\cdot q)+\\overline{p}+\\overline{q}=((p\\cdot q)+\\overline{p})+\\overline{q}$     by associative law\n5. $(p\\cdot q)+\\overline{p}=(p+\\overline{p})\\cdot(q+\\overline{p})$      by distributive law\n6. $(p+\\overline{p}) = 1$                                 by inverse law\n7. $1\\cdot(q+\\overline{p})=q+\\overline{p}$                      by identity law\n8. $q+\\overline{p}+\\overline{q}=\\overline{p}+1$                       by inverse law\n9. $\\overline{p}+1=1$                                    by null law\n**expression will always be true**\n\n### Simplifying $(p \\cdot \\overline{q}) \\cdot (\\overline{p} + q)$\n1. $(p \\cdot \\overline{q})\\cdot(\\overline{p} + q)=p\\cdot\\overline{p}\\cdot\\overline{q}+p\\cdot q\\cdot\\overline{q}$    by distributive law\n2. $p\\cdot\\overline{p}\\cdot\\overline{q}+p\\cdot q\\cdot\\overline{q}=0\\cdot\\overline{q}+p\\cdot 0$    by inverse law\n3. $0\\cdot\\overline{q}+p\\cdot 0=0+0=0$                      by null law\n**expression will always be false**\n\n### Simplifying $((\\overline{p}\\cdot q)\\cdot(p \\cdot q))\\cdot\\overline{q}$\n1. $((\\overline{p}\\cdot q)\\cdot(p \\cdot q))\\cdot\\overline{q}=\\overline{p}\\cdot q\\cdot p\\cdot q\\cdot\\overline{q}$      by associative law\n2. $\\overline{p}\\cdot q\\cdot p\\cdot q\\cdot\\overline{q}=\\overline{p}\\cdot p\\cdot q\\cdot q\\cdot\\overline{q}$         by commutative law\n3. $\\overline{p}\\cdot p\\cdot q\\cdot q\\cdot\\overline{q}=\\overline{p}\\cdot p\\cdot q\\cdot\\overline{q}$             by  idempotent law\n4. $\\overline{p}\\cdot p\\cdot q\\cdot\\overline{q}=0\\cdot 0$                          by inverse law"
  },
  {
    "id": "2019A_FE_AM_2",
    "question": "What is the Hamming distance of bit strings 10101 and 11110?",
    "options": [
      "0",
      "2",
      "3",
      "5"
    ],
    "correctAnswer": 2,
    "solution": "### Hamming distance\n\nA metric for comparing two binary data strings. While comparing two binary strings of equal length, Hamming distance is the number of bit positions in which the two bits are different.\n\n### Calculating Hamming distance\n\nIn order to calculate the Hamming distance between two strings, and , we perform their XOR operation, (a⊕b), and then count the total number of 1s in the resultant string.\n\n##### Example\n\n101 ⊕ 111 = 010, d(011, 111) = 1\n\n011 ⊕ 101 = 110, d(011, 101) = 2\n\n010 ⊕ 101 = 111, d(010, 101) = 3\n\n##### Therefore\n\n10101 ⊕ 11110 = 01011, d(10101, 11110) = 3"
  },
  {
    "id": "2019A_FE_AM_3",
    "question": "A candy box contains four flavors of candies: 6 lemon-flavored, 12 strawberry-flavored, 8 orange-flavored, and 4 grape-flavored. When a candy is chosen from the box, what is the probability that it is either lemon- or orange-flavored?",
    "options": [
      "$4\\over{9}$",
      "$7\\over{15}$",
      "$6\\over{11}$",
      "$7\\over{8}$"
    ],
    "correctAnswer": 1,
    "solution": "### Total number of candies\n\n6 lemon + 12 strawberry + 8 orange + 4 grape = 30 total candies\n\n### Finding probability of choosing a lemon OR orange-flavored candy\n\n$6\\over{30}$+$8\\over{30}$=$14\\over{30}$=$7\\over{15}$"
  },
  {
    "id": "2019A_FE_AM_4",
    "question": "A vehicle travels along a circle in the figure below. Two sensors L and R are attached to the left and right rear wheels, whose revolution speeds are independently controlled. Sensors L and R are photo reflective sensors, whose values change according to the ratio of black and white regions they pass over. If the ratio increases, the sensor value decreases, and if the ratio decreases, the sensor value increases. Which of the following is an appropriate control for ensuring that the vehicle travels along the black outline of the circle? Here, if the values of the two sensors match, the revolution speeds of the motors return to the initial speed.\n\n![Image](Files/Pasted%20image%2020241019175703.png)\n\n![Image](Files/Pasted%20image%2020241019180752.png)",
    "options": [
      "A",
      "B",
      "C",
      "D"
    ],
    "correctAnswer": 1,
    "solution": ""
  },
  {
    "id": "2019A_FE_AM_5",
    "question": "What is the result after evaluation of the following postfix expression? Here, symbols +, -, x, and ÷ represent the arithmetic operators of addition, subtraction, multiplication, and division, respectively.\n\n5 4 6 + x 4 9 3 ÷ + x",
    "options": [
      "98",
      "154",
      "238",
      "350"
    ],
    "correctAnswer": 3,
    "solution": "### Solving postfix expression 5 4 6 + x 4 9 3 ÷ + x\n\n**1. push 5 to stack**\n\n| 5   |\n| --- |\n\n**2. push 4 to stack**\n\n| 4   |\n| --- |\n| 5   |\n\n**3. push 6 to stack**\n\n| 6   |\n| --- |\n| 4   |\n| 5   |\n\n**4. add 4 and 6**\n\n| 4 + 6 = 10 |\n| ---------- |\n| 5          |\n\n**5. multiply 10 and 5**\n\n| 5 x 10 = 50 |\n| ----------- |\n\n**6. push 4 to stack**\n\n| 4   |\n| --- |\n| 50  |\n\n**7. push 9 to stack**\n\n| 9   |\n| --- |\n| 4   |\n| 50  |\n\n**8. push 3 to stack**\n\n| 3   |\n| --- |\n| 9   |\n| 4   |\n| 50  |\n\n**9. divide 9 and 3**\n\n| 9 / 3 = 3 |\n| --------- |\n| 4         |\n| 50        |\n\n**10. add 4 and 3**\n\n| 4 + 3 = 7 |\n| --------- |\n| 50        |\n\n**11. multiply 50 and 7**\n\n| 50 x 7 = 350 |\n| ------------ |"
  },
  {
    "id": "2019A_FE_AM_6",
    "question": "Two stack operations are defined:\nPUSH n: Pushes a data (integer value n) to the stack.\nPOP: Pops a data from the stack.\nFor an empty stack, which of the following is the result of performing stack operations in the sequence below? PUSH 1 → PUSH 5 → POP → PUSH 7 → PUSH 6 → PUSH 4 → POP → POP → PUSH 3\n\n![Image](Files/Pasted%20image%2020241020164843.png)",
    "options": [
      "A",
      "B",
      "C",
      "D"
    ],
    "correctAnswer": 2,
    "solution": "### Visualizing the stack operations\n\n**1. PUSH 1**\n\n|     |\n| --- |\n| 1   |\n\n**2. PUSH 5**\n\n|     |\n| --- |\n| 5   |\n| 1   |\n\n**3. POP**\n\n|     |\n| --- |\n| 1   |\n\n**4. PUSH 7**\n\n|     |\n| --- |\n| 7   |\n| 1   |\n\n**5. PUSH 6**\n\n|     |\n| --- |\n| 6   |\n| 7   |\n| 1   |\n\n**6. PUSH 4**\n\n|     |\n| --- |\n| 4   |\n| 6   |\n| 7   |\n| 1   |\n\n**7. POP**\n\n|     |\n| --- |\n| 6   |\n| 7   |\n| 1   |\n\n**8. POP**\n\n|     |\n| --- |\n| 7   |\n| 1   |\n\n**9. PUSH 3**\n\n|     |\n| --- |\n| 3   |\n| 7   |\n| 1   |"
  },
  {
    "id": "2019A_FE_AM_7",
    "question": "In a table search, which of the following is a characteristic of the search technique known as hashing?",
    "options": [
      "It is a method in which a collision between storage locations of data does not occur.",
      "It is a search technique that uses a binary tree.",
      "The storage locations of data are determined based on the function values of their keys.",
      "The time required to perform the search is approximately proportional to the size of the entire table."
    ],
    "correctAnswer": 2,
    "solution": "### What is Hash Table?\n\n- A Hash table is defined as a data structure used to insert, look up, and remove key-value pairs quickly. It operates on the [hashing concept](https://www.geeksforgeeks.org/what-is-hashing/), where each key is translated by a hash function into a distinct index in an array. The index functions as a storage location for the matching value. In simple words, it maps the keys with the value."
  },
  {
    "id": "2019A_FE_AM_8",
    "question": "The binary search algorithm is used to search for a given item when items are sorted. If the number of items is 1 million, which of the following is the closest to the maximum number of comparisons required to find the item?",
    "options": [
      "15",
      "20",
      "25",
      "30"
    ],
    "correctAnswer": 1,
    "solution": "### Calculating time complexity of binary search algorithm\n\n**Time complexity of binary search**\n$O_{{\\log_{2}n}}$\nSearching 1 million items means n = 1,000,000\n\n\n$\\frac{\\log_{10}(1,000,000)}{\\log_{10}(2)}=\\log_{2}(1,000,000)$\n\n$\\log_{10}(1,000,000)=6$\n\n$\\log_{10}(2)\\approx0.301$\n\n$\\frac{6}{0.301}=19.93\\approx20$"
  },
  {
    "id": "2019A_FE_AM_9",
    "question": "In object-oriented programming, which of the following is an explanation of overriding that achieves polymorphism?",
    "options": [
      "A feature that allows a class to provide a specific implementation of a method that is already provided by one of its super classes",
      "Creating a class through abstraction by collecting common properties of multiple classes",
      "Defining multiple methods in a class that have the same name, but differ in terms of the number of arguments, argument types, or argument order",
      "Hiding internal contracts and structures of an object from its external specification"
    ],
    "correctAnswer": 0,
    "solution": "### What is polymorphism?\n\n- Polymorphism is a feature of object-oriented programming languages that allows a specific routine to use variables of different types at different times. It is the ability of a programming language to present the same interface for several different underlying data types and different objects to respond in a unique way to the same message.\n- Polymorphism describes the concept that you can access objects of different types through the same interface."
  },
  {
    "id": "2019A_FE_AM_10",
    "question": "A CPU has a clock frequency of 2.0 GHz. When the instructions consist of three types, as shown in the table below, what is the approximate CPU performance in MIPS?\n\n|     Time      | Execution Time (clocks) | Frequency of appearance ($\\%$) |\n| :-----------: | :---------------------: | :----------------------------: |\n| Instruction 1 |           15            |               40               |\n| Instruction 2 |           10            |               20               |\n| Instruction 3 |           10            |               40               |",
    "options": [
      "16.7",
      "120",
      "167",
      "200"
    ],
    "correctAnswer": 2,
    "solution": "### Finding clock frequency\n\nThe clock frequency is given as 2.0 GHz, which is equal to $2.0\\times 10^9$ cycles per second.\n\n### Average cycles per instruction\n\nTo find the average CPI, we will multiply each instruction’s clock cycles by its frequency of appearance (as a decimal), then sum them:\n$CPI_{avg}=(15\\times.40)+(10\\times.20)+(10\\times.40)=6+2+4=12$\n\n### Calculate MIPS\n\n$MIPS=\\frac{2.0\\times10^9}{12\\times10^6}=\\frac{2}{12}\\times 10^3=0.1667\\times 10^3=166.67\\approx 167MIPS$"
  },
  {
    "id": "2019S_FE_AM_1",
    "question": "For an eight-bit integer x represented in two’s complement format, which of the following yields the value of 5x? Here, the overflow or underflow can be ignored in this multiplication.",
    "options": [
      "Shift x to the left by 1 bit, then add the initial value of x to it.",
      "Shift x to the left by 2 bits, then add the initial value of x to it.",
      "Shift x to the right arithmetically by 1 bit, then subtract the initial value of x from it.",
      "Shift x to the right arithmetically by 2 bits, then subtract the initial value of x from it."
    ],
    "correctAnswer": 1,
    "solution": "## **Explanation:**\n\nTo multiply an integer by 5, we can break it down as:\n#### $5x=4x+x$\n\n- Shifting **x** to the left by 2 bits gives **4x** (since left-shifting by 2 bits is equivalent to multiplying by $2^2$ which is equal to 4).\n- Adding the original **x** to this gives **4x + x = 5x**.\n\n### Overview of other options:\n\n- **a)** Shifting **x** left by 1 bit gives **2x**, and adding **x** gives **3x**, not **5x**.\n- **c)** Shifting **x** right arithmetically by 1 bit divides it by 2 (rounding towards negative), and subtracting **x** gives something unrelated to **5x**.\n- **d)** Shifting **x** right arithmetically by 2 bits divides it by 4, and subtracting **x** gives something unrelated to **5x**."
  },
  {
    "id": "2019S_FE_AM_2",
    "question": "How many four-digit decimal numbers are made from four (4) different digits between 0 and 9? Here, a four-digit decimal number has a non-zero leading digit.",
    "options": [
      "4320",
      "4436",
      "4536",
      "5040"
    ],
    "correctAnswer": 2,
    "solution": "## **Explanation:**\n\nWe need to calculate how many **four-digit decimal numbers** can be made from **four different digits** between 0 and 9, ensuring that the **leading digit is non-zero**.\n\n1. **First digit**: The leading digit must be from 1 to 9 (9 choices).\n2. **Second digit**: This can be any of the 9 remaining digits (including 0 but excluding the first digit).\n3. **Third digit**: This can be any of the remaining 8 digits.\n4. **Fourth digit**: This can be any of the remaining 7 digits.\n\nSo, the total number of possible four-digit numbers is:\n#### $9~\\times~9~\\times~8~\\times~7=4536$"
  },
  {
    "id": "2019S_FE_AM_3",
    "question": "What is the value of the postfix expression below when variables A, B, C, and D have values 4, 3, 5, and 6, respectively? Here, symbols ‘$+$’, ‘$-$’, ‘$\\times$’, and ‘$/$’ represent the arithmetic operators of addition, subtraction, multiplication, and division, respectively.\n\n![Image](Files/Pasted%20image%2020241020100735.png)",
    "options": [
      "-3",
      "0",
      "3",
      "40/3"
    ],
    "correctAnswer": 1,
    "solution": "## **Explanation:**\n\nIf the arithmetic expression is in **postfix notation**, then the operators come **after** the operands. Find 2 operands that has an operator **after** them. Then perform the operation according to the operator. Repeat until you get the result. In this problem, substitute the variables with their respective values first before solving the expression.\n\n![Image](Files/Pasted%20image%2020241020102836.png)\n\nAfter performing the operations correctly, we get 0 as our answer, so the answer to the question is **b)**."
  },
  {
    "id": "2019S_FE_AM_4",
    "question": "Which of the following is an appropriate explanation of the feedback control?",
    "options": [
      "It performs a control in a predetermined order.",
      "It performs a control so that the output matches the target.",
      "It performs a control to avoid external disturbances to the output.",
      "It performs a control without using the output."
    ],
    "correctAnswer": 1,
    "solution": "## **Explanation:**\n\n**Feedback control** is a process where the output of a system is measured, and adjustments are made to ensure that the output remains aligned with the desired target or set point. The feedback loop uses the difference between the actual output and the target to adjust the system's behavior.\n\n### Overview of other options:\n\n- **a)** Performing control in a predetermined order describes **open-loop control**, not feedback control.\n- **c)** Controlling to avoid external disturbances may describe a type of feedback control but is not a complete or precise explanation.\n- **d)** Performing control without using the output refers to **open-loop control**, where feedback from the output is not used to adjust the system."
  },
  {
    "id": "2019S_FE_AM_5",
    "question": "Which of the following is a binary search tree?\n\n![Image](Files/Pasted%20image%2020241020103659.png)",
    "options": [
      "A",
      "B",
      "C",
      "D"
    ],
    "correctAnswer": 1,
    "solution": "## **Explanation:**\n\nA **binary search tree (BST)** is a type of binary tree where:\n\n1. Each node has at most two children.\n2. For any given node:\n    - The **left child** contains a value **less than** the value of the node.\n    - The **right child** contains a value **greater than** the value of the node.\n3. This property applies recursively to all nodes in the tree.\n\n### Overview of other options:\n\n- **a)** The right child of the node containing the element 15 is contains an element that is lesser than its parent which violates the rules of a BST.\n- **c)** The right child of the node containing the element 16 is contains an element that is lesser than its parent which violates the rules of a BST.\n- **d)** The right child of the node containing the element 20 is contains an element that is lesser than its parent which violates the rules of a BST.\n\n![Image](Files/Pasted%20image%2020241020103710.png)"
  },
  {
    "id": "2019S_FE_AM_6",
    "question": "When the procedure described below is executed in sequence for an empty stack and empty queue, what is the value assigned to variable x? Here, the functions used in the procedure are defined as follows:\n\n[Function definitions]\n\n\tpush(y): pushes data y onto the top of the stack.\n\n\tpop(): removes the data from the top of the stack and returns it as the function value.\n\n\tenq(y): inserts data y at the tail of the queue.\n\n\tdeq(): removes the data from the head of the queue and returns it as the function value.\n\n[Procedure]\n\n\tpush(a)\n\tpush(b)\n\tenq(pop())\n\tenq(c)\n\tpush(d)\n\tpush(deq())\n\tx ← pop()",
    "options": [
      "A",
      "B",
      "C",
      "D"
    ],
    "correctAnswer": 1,
    "solution": "## **Explanation:**\n\n### Initial conditions:\n\n- **Stack**: empty\n- **Queue**: empty\n\n### Procedure:\n\n1. **push(a)**: Pushes **'a'** onto the stack.\n    **Stack**: `['a']`\n    **Queue**: `[]`\n\n2. **push(b)**: Pushes **'b'** onto the stack.\n    **Stack**: `['a', 'b']`\n    **Queue**: `[]`\n\n3. **enq(pop())**: Pops the top element from the stack (**'b'**) and enqueues it into the queue.\n    **Stack**: `['a']`\n    **Queue**: `['b']`\n\n4. **enq(c)**: Enqueues **'c'** into the queue.\n    **Stack**: `['a']`\n    **Queue**: `['b', 'c']`\n\n5. **push(d)**: Pushes **'d'** onto the stack.\n    **Stack**: `['a', 'd']`\n    **Queue**: `['b', 'c']`\n\n6. **push(deq())**: Dequeues the front element of the queue (**'b'**) and pushes it onto the stack.\n    **Stack**: `['a', 'd', 'b']`\n    **Queue**: `['c']`\n\n7. **x ← pop()**: Pops the top element from the stack (**'b'**) and assigns it to **x**.\n    **Stack**: `['a', 'd']`\n    **Queue**: `['c']`\n\nThe value of x is 'b'. Therefore the answer to the question is **b)**."
  },
  {
    "id": "2019S_FE_AM_7",
    "question": "For a function f(x, y) defined below, what is the value of f(775, 527)? Here, x mod y represents the remainder after division of x by y.\n\n\tf(x, y): if y = 0 then return x else return f(y, x mod y)",
    "options": [
      "0",
      "31",
      "248",
      "527"
    ],
    "correctAnswer": 1,
    "solution": "## **Explanation:**\n\nTo determine the value of the function $f(775,527)$ defined as:\n\n#### $f(x,y)=x~if~y=0,~else~f(y,x~mod  y)$\n\nwe will follow the recursive steps defined in the function.\n\n### Step 1: Initial Call\n\n- $f(775,527)$\n\nSince $527 \\neq 0$, we need to evaluate $f(775 \\mod 527)$.\n\n### Step 2: Calculate $775 \\mod 527$\n\n$775 \\div 527 = 1 \\quad \\text{(integer part)}$\n$775 - (1 \\times 527) = 775 - 527 = 248$\n\nSo, $775 \\mod 527 = 248$.\n\nNow, we have:\n\n$f(775, 527) = f(527, 248)$\n\n### Step 3: Second Call\n\n- $f(527,248)$\n\nSince $248 \\neq 0$, we evaluate $f(527 \\mod 248)$.\n\n### Step 4: Calculate $527 \\mod 248$\n\n$527 \\div 248 = 2 \\quad \\text{(integer part)}$\n$527 - (2 \\times 248) = 527 - 496 = 31$\n\nSo, $527 \\mod 248 = 31$.\n\nNow, we have:\n\n$f(527, 248) = f(248, 31)$\n\n### Step 5: Third Call\n\n- $f(248, 31)$\n\nSince $31 \\neq 0$, we evaluate $f(248 \\mod 31)$.\n\n### Step 6: Calculate $248 \\mod 31$\n\n$248 \\div 31 = 8 \\quad \\text{(integer part)}$\n$248 - (8 \\times 31) = 248 - 248 = 0$\n\nSo, $248 \\mod 31 = 0$.\n\nNow, we have:\n\n$f(248, 31) = f(31, 0)$\n\n### Step 7: Fourth Call\n\n- $f(31, 0)$\n\nSince $y=0$, we return $x$:\n\n$f(31,0)=31$\n\n### Final Result\n\nThus, the value of $f(775,527)$ is **31**.\n\n**Answer: b) 31**"
  },
  {
    "id": "2019S_FE_AM_8",
    "question": "The flowchart below shows the algorithm of concatenating two character strings in X and Y, with the resulting character string in Z. Which of the following is the appropriate pair of operations to insert in the blanks, A and B? Here, X and Y are character arrays of dimensions m and n, respectively, where the i-th character of each string is stored as the i-th element of the character array.\n\n![Image](Files/Pasted%20image%2020241020111646.png)\n\n![Image](Files/Pasted%20image%2020241020111705.png)",
    "options": [
      "A",
      "B",
      "C",
      "D"
    ],
    "correctAnswer": 0,
    "solution": "## **Explanation:**\n\nTo correctly fill in the blanks **A** and **B** in the algorithm for concatenating two character strings **X** and **Y** into a resulting character string **Z**, let's break down the operations involved.\n\n### Given Information:\n\n- **X** is a character array of dimension **m**.\n- **Y** is a character array of dimension **n**.\n- The resulting string **Z** will have a total length of **m + n**.\n\n### Flowchart Analysis:\n\n1. **Loop 1** iterates over the characters in **X** from **1** to **m**.\n\n    - In this loop, we need to copy characters from **X** to **Z**. Each character from **X** should be placed in the first part of **Z**.\n    - Thus, the operation should be: **A: X(k) → Z(k)** (where k varies from 1 to m).\n\n2. **Loop 2** iterates over the characters in **Y** from **1** to **n**.\n\n    - In this loop, we need to copy characters from **Y** to **Z** starting after the last character from **X**. Since the first **m** positions in **Z** are filled by **X**, the characters from **Y** should start from position **m + 1** in **Z**.\n    - Thus, the operation should be: **B: Y(k) → Z(m + k)** (where k varies from 1 to n).\n\n### **Conclusion:**\n\nBased on the analysis, the appropriate operations to insert in the blanks **A** and **B** are:\n\n- **A**: **X(k) → Z(k)**\n- **B**: **Y(k) → Z(m + k)**\n\n### **Final Answer:**\n\nThe correct pair of operations is:\n**a)** $X(k)→Z(k)$ and $Y(k)→Z(m+k)$\n**Answer: a)**\n\n![Image](Files/Pasted%20image%2020241020111719.png)"
  },
  {
    "id": "2019S_FE_AM_9",
    "question": "For a processor running at 50 MIPS, what is the average execution time per instruction?",
    "options": [
      "20 ns",
      "50 ns",
      "2 $\\mu$s",
      "5 $\\mu$s"
    ],
    "correctAnswer": 0,
    "solution": "## **Explanation:**\n\nTo calculate the average execution time per instruction for a processor running at 50 MIPS (Million Instructions Per Second), we can use the following formula:\n\n#### $Execution~Time~per~Instruction=\\frac{1}{\\text{MIPS}}$\n\n### Step 1: Convert MIPS to Execution Time\n\nGiven that the processor runs at 50 MIPS, we can calculate the execution time as follows:\n\n$\\text{Execution Time per Instruction} = \\frac{1}{50 \\text{ MIPS}} = \\frac{1}{50 \\times 10^6} \\text{ seconds}$\n\n### Step 2: Calculate Execution Time\n\nNow, calculate the execution time:\n\n$\\text{Execution Time per Instruction} = \\frac{1}{50,000,000} = 20 \\text{ ns}$\n\n### Final Answer\n\nThus, the average execution time per instruction is **20 ns**.\n\n**Answer: a) 20 ns**"
  },
  {
    "id": "2019S_FE_AM_10",
    "question": "Which of the following is an appropriate characteristic of SRAM compared to DRAM? Here, SRAM and DRAM are compared in products manufactured in the same or similar semiconductor geometric process.",
    "options": [
      "SRAM consumes more power, particularly when idle, compared to DRAM.",
      "SRAM is non-volatile, whereas DRAM is volatile.",
      "SRAM needs to be refreshed, whereas DRAM does not.",
      "SRAM uses more transistors in a memory cell compared to DRAM."
    ],
    "correctAnswer": 3,
    "solution": "## **Explanation:**\n\n- **SRAM (Static Random Access Memory)** uses **six transistors** (6T) to store a single bit of data. This design allows SRAM to maintain data without needing to refresh it, making it faster and more stable than DRAM.\n- **DRAM (Dynamic Random Access Memory)**, on the other hand, typically uses **one transistor and one capacitor** (1T1C) to store each bit. This design is simpler and allows DRAM to have a higher density and lower cost per bit compared to SRAM.\n\n### Overview of Other Options:\n\n- **a)** **SRAM consumes more power, particularly when idle, compared to DRAM.** This is incorrect; SRAM generally consumes less power when active but can consume more power during idle states.\n- **b)** **SRAM is non-volatile, whereas DRAM is volatile.** This is incorrect; both SRAM and DRAM are volatile memory types, meaning they lose their stored data when power is turned off.\n- **c)** **SRAM needs to be refreshed, whereas DRAM does not.** This is incorrect; DRAM requires periodic refreshing to maintain data, while SRAM does not require refreshing.\n\nTherefore, the answer is **d)**."
  },
  {
    "id": "2019S_FE_AM_11",
    "question": "In a memory system that has a cache memory, which of the following causes an increase in the average memory access time?",
    "options": [
      "A decrease in the access time to the cache memory",
      "A decrease in the cache hit rate",
      "A decrease in the cache miss penalty",
      "A decrease in the cache miss rate"
    ],
    "correctAnswer": 1,
    "solution": "## **Explanation:**\n\n- The **average memory access time** (AMAT) is calculated using the formula:  \n    $\\text{Average~Memory~Access~time} = \\text{Hit time} + (\\text{Miss rate} \\times \\text{Miss penalty})$\n    \n- A **decrease in the cache hit rate** means that fewer memory accesses are satisfied by the cache. As a result, more accesses will require fetching data from the slower main memory, increasing the average memory access time.\n\n### Overview of Other Options:\n\n- **a)** **A decrease in the access time to the cache memory.** This would decrease the average memory access time since faster cache access improves the overall performance.\n- **c)** **A decrease in the cache miss penalty.** This would also decrease the average memory access time, as it reduces the time taken to retrieve data from main memory when a cache miss occurs.\n- **d)** **A decrease in the cache miss rate.** This would lead to a decrease in average memory access time since fewer misses mean that most accesses are satisfied by the cache."
  },
  {
    "id": "2019S_FE_AM_12",
    "question": "There exists a storage system in which one (1) block is composed of eight (8) sectors of 500 bytes each, and the storage area is block-wise allocated to the files. When a 2,000-byte file and 9,000-byte file are to be saved, what is the total number of sectors that is allocated to these two (2) files? Here, the sectors that are occupied by the directory information and other such management information can be ignored.",
    "options": [
      "22",
      "26",
      "28",
      "32"
    ],
    "correctAnswer": 3,
    "solution": "## **Explanation:**\n\n### Storage System Details:\n\n- **1 block** = **8 sectors**\n- **1 sector** = **500 bytes**\n- Therefore, **1 block** = $8 \\text{ sectors} \\times 500 \\text{ bytes/sector} = 4,000 \\text{ bytes}$\n\n### File Allocations:\n\n1. **2,000-byte file:**\n    \n    - $\\text{Sectors needed} = \\lceil \\frac{2000 \\text{ bytes}}{500 \\text{ bytes/sector}} \\rceil = \\lceil 4 \\rceil = 4 \\text{ sectors}$\n\tSince 4 sectors are needed, you need 1 block which houses 8 sectors. Therefore, in a 2000-byte file, 8 sectors are allocated even if the file doesn't use all sectors.\n2. **9,000-byte file:**\n    \n    - $\\text{Sectors needed} = \\lceil \\frac{9000 \\text{ bytes}}{500 \\text{ bytes/sector}} \\rceil = \\lceil 18 \\rceil = 18 \\text{ sectors}$\n    Since 18 sectors are needed, you need 3 blocks which houses 24 sectors, Therefore, in a 9000-byte file, 24 sectors are allocated even if the file doesn't use all sectors.\n\n### **Conclusion:**\n\nSo 8 + 24 = 32 sectors are allocated to these 2 files.\nTherefore, the answer is **d)**."
  },
  {
    "id": "2019S_FE_AM_13",
    "question": "Which of the following is an appropriate description concerning the recording method of RAID5?",
    "options": [
      "It distributes the data over multiple hard disk drives, writes the data in units of bits, and writes the ECC (Error Correction Codes) on multiple hard disk drives.",
      "It distributes the data over multiple hard disk drives, writes the data in units of blocks, and distributes and writes the parity on multiple hard disk drives.",
      "It distributes the data over multiple hard disk drives, writes the data in units of bytes, and writes the parity on one (1) hard disk drive.",
      "It writes the same data on two (2) hard disk drives to create a mirror disk."
    ],
    "correctAnswer": 1,
    "solution": "## **Explanation:**\n\n- **RAID 5** is a type of **redundant array of independent disks (RAID)** that provides data redundancy and improved performance.\n- In RAID 5:\n    - **Data is striped across multiple drives** in units called blocks. This means that data is divided into blocks and written across several disks.\n    - **Parity information** (used for error recovery) is also distributed across all drives. This allows for the recovery of data in case one of the drives fails without the need for a complete mirror of the data, making RAID 5 efficient in terms of storage utilization.\n\n### Overview of Other Options:\n\n- **a)** **It distributes the data over multiple hard disk drives, writes the data in units of bits, and writes the ECC (Error Correction Codes) on multiple hard disk drives.**  \n    This is incorrect as RAID 5 does not write in units of bits but in blocks, and it specifically uses parity rather than ECC.\n    \n- **c)** **It distributes the data over multiple hard disk drives, writes the data in units of bytes, and writes the parity on one (1) hard disk drive.**  \n    This is incorrect; RAID 5 writes data in blocks and distributes the parity across multiple drives, not just one.\n    \n- **d)** **It writes the same data on two (2) hard disk drives to create a mirror disk.**  \n    This describes **RAID 1**, which is a mirroring method, rather than RAID 5.\n    \n\nThus, **b)** is the correct description of RAID 5."
  },
  {
    "id": "2019S_FE_AM_14",
    "question": "Which of the following is the most appropriate description of a dual system?",
    "options": [
      "It loads the online processing program of the active system on to a backup system and sets it to a standby status. In the event of a failure in the active system, it immediately switches to the backup system and continues the processing.",
      "It prepares a duplicate processor, memory, communication channel, and power supply system and continues the processing even in the event of a failure in any of the devices.",
      "It provides a duplicate system for performing the same processing and checks the accuracy of the processing by collating the processing results. In the event of a failure in either system, it continues the processing by the degraded operation.",
      "It provides an active system for performing online processing and keeps a backup system on standby while batch processing is being performed. In the event of a failure in the active system, it switches to the backup system and continues the online processing"
    ],
    "correctAnswer": 2,
    "solution": "## **Explanation:**\n\n- A **dual system** a system configuration in which two CPUs perform the same processing and compare the processing results to each other. This configuration is applied when the process is not allowed to stop, even for a moment. If one CPU fails, the system cuts off the failed CPU and continues processing on the other CPU.\n\n### Overview of Other Options:\n\n- **a)** This describes a **hot standby system**. In this setup, a backup system is kept ready to take over the operations of an active system in the event of a failure. It emphasizes immediate availability without active processing of results by the backup system, which is common in hot standby configurations.\n\n- **b)** This describes a **fault-tolerant system** or **redundant system**. In this configuration, all components (processors, memory, etc.) are duplicated to ensure that the system continues functioning even if one component fails. The focus here is on hardware redundancy rather than system-level redundancy or active verification of outputs.\n    \n- **d)** This describes a **duplex system**. In this arrangement, one system is actively processing while another is on standby, ready to take over if the active system fails. The term 'duplex' is often associated with maintaining two systems that can alternate tasks but doesn't necessarily focus on cross-checking outputs like a dual system does.\n    \n\nThus, **c)** is the correct and most suitable description of a dual system."
  },
  {
    "id": "2019S_FE_AM_15",
    "question": "A system has devices with availability R, connected as shown in the figure below. Which of the following is the expression that represents the availability of the entire system? Here, a parallel connection only requires either of the two devices to be functional, whereas a series connection requires both the devices to be functional.\n\n![Image](Files/Pasted%20image%2020241020124140.png)",
    "options": [
      "$(1- (1-R)^2 )^2$",
      "$(1- (1-R^2))^2$",
      "$1- (1-R)^4$",
      "$1- (1-R^2)^2$"
    ],
    "correctAnswer": 0,
    "solution": "## **Explanation:**\n\n1. **Parallel Connection**:\n    - For two devices in parallel, the availability is given by the formula: \n\t    $A_{\\text{parallel}} = 1 - (1 - R)^2$\n    \n    This formula means the system remains available as long as at least one of the devices is functional.\n    \n2. **Series Connection**:\n    \n    - For two devices in series, the availability is simply the product of their availabilities: \n\t    $A_{\\text{series}} = R \\times R = R^2$\n\n### Combining the Configurations\n\nSince the two parallel devices are connected in a series, we can denote:\n\n- Let $A_{\\text{parallel}}$ be the availability of the first parallel configuration (which consists of two devices).\n- The overall availability of the series connection with the result from the parallel configuration is: $A_{\\text{total}} = A_{\\text{parallel}}^2 = \\left(1 - (1 - R)^2\\right)^2$\n\n### **Conclusion**\n\nThe most appropriate expression representing the availability of the entire system with the described configuration is:\n\n**a)** $(1- (1-R)^2 )^2$ \n\nThis corresponds to the availability of the two parallel devices squared."
  },
  {
    "id": "2019S_FE_AM_16",
    "question": "Which of the following is an appropriate explanation of paging?",
    "options": [
      "A method of memory management in which multiple records are read and written as a block on an auxiliary storage",
      "A method of memory management in which the main memory is divided into multiple areas so that reading and writing can be performed simultaneously",
      "A method of memory management in which the programs are relocated for execution in a different area of the main memory",
      "A method of memory management in which the virtual memory space and real memory space are divided into fixed-length blocks for management"
    ],
    "correctAnswer": 3,
    "solution": "## **Explanation:**\n\n- **Paging** is a memory management scheme that eliminates the need for contiguous allocation of physical memory and thus eliminates the problems of fitting varying sized memory chunks onto the backing store.\n- In this method, both the **virtual memory** (used by processes) and **physical memory** (actual RAM) are divided into fixed-size blocks called **pages** (for virtual memory) and **frames** (for physical memory).\n- When a program is executed, its pages can be loaded into any available memory frames, which helps in utilizing memory more efficiently and allows for easier management of memory allocation.\n\n### Overview of Other Options:\n\n- **a)** **A method of memory management in which multiple records are read and written as a block on auxiliary storage.**\n    \n    - This describes **block storage** or **batch processing**, not specifically paging.\n- **b)** **A method of memory management in which the main memory is divided into multiple areas so that reading and writing can be performed simultaneously.**\n    \n    - This is a more general description of memory segmentation or parallel processing rather than paging.\n- **c)** **A method of memory management in which the programs are relocated for execution in a different area of the main memory.**\n    \n    - This refers to **memory relocation** or **dynamic loading**, which is not specifically the definition of paging.\n\nThus, option **d** accurately describes the concept of paging in memory management."
  },
  {
    "id": "2019S_FE_AM_17",
    "question": "Which of the following is a method that performs data transfer between the main memory and a low-speed output device via a high-speed auxiliary storage device to increase the throughput of the entire system?",
    "options": [
      "Blocking",
      "Paging",
      "Spooling",
      "Swapping"
    ],
    "correctAnswer": 2,
    "solution": "## **Explanation:**\n\n- **Spooling** (Simultaneous Peripheral Operation On-Line) is a process that allows data to be temporarily stored in a high-speed storage area (such as a disk) before being sent to a slower output device (like a printer).\n- This technique enables the system to continue processing other tasks while the data is being transferred, effectively improving the overall throughput and efficiency of the system by allowing I/O operations to occur concurrently with computation.\n\n### Overview of Other Options:\n\n- **a)** **Blocking**: This typically refers to a method of grouping data into blocks for more efficient storage and transfer but does not directly involve the transfer process between devices as described.\n    \n- **b)** **Paging**: This is a memory management scheme that involves dividing memory into fixed-size pages and does not involve data transfer between a high-speed storage device and output devices.\n    \n- **d)** **Swapping**: This refers to the process of moving data between main memory and disk storage to free up memory but does not specifically relate to output devices or the auxiliary storage acting as a buffer for data transfer to slow devices.\n    \n\nThus, **c) Spooling** is the correct answer as it directly addresses the data transfer method described in your question."
  },
  {
    "id": "2019S_FE_AM_18",
    "question": "In the figure below, data are sent continuously for T seconds from the send task to the receive task. When the volume of the data sent per second is S and volume of the data received per second is R, which of the following is an appropriate relational expression for buffer size L for a buffer that does not overflow? Here, the transmission speed for the send task is faster than the transmission speed for the receive task, and there is sufficient time between the transmissions.\n\n![Image](Files/Pasted%20image%2020241020124140.png)",
    "options": [
      "$L<(R-S)\\times T$",
      "$L<(S-R)\\times T$",
      "$L\\geq(R-S)\\times T$",
      "$L\\geq(S-R)\\times T$"
    ],
    "correctAnswer": 3,
    "solution": "## **Explanation:**\n\nTo determine the appropriate relational expression for buffer size $L$ for a buffer that does not overflow, we need to analyze the data transmission dynamics between the send and receive tasks over a time period $T$.\n\n### Given:\n\n- **Volume of data sent per second**: $S$\n- **Volume of data received per second**: $R$\n- **Transmission speed for the send task is faster than for the receive task**: $S>R$\n\n### Explanation:\n\nSince the send task transmits data at a faster rate than the receive task (i.e., $S>R$), this means that there will be a backlog of data that needs to be buffered since the send task will continually produce more data than the receive task can handle.\n\n1. **Net Data Sent in $T$ Seconds**:\n    \n    - In $T$seconds, the send task will send: $\\text{Total Sent} = S \\times T$\n2. **Net Data Received in $T$ Seconds**:\n    \n    - In the same $T$ seconds, the receive task will receive: $\\text{Total Received} = R \\times T$\n3. **Net Data That Needs to Be Buffered**:\n    \n    - The amount of data that needs to be buffered (the difference between sent and received) is: $\\text{Data to Buffer} = \\text{Total Sent} - \\text{Total Received} = (S \\times T) - (R \\times T) = (S - R) \\times T$\n\n### Buffer Size Requirement:\n\nFor the buffer to not overflow, the buffer size $L$ must be at least equal to the amount of data that needs to be buffered:\n\n$L \\geq (S - R) \\times T$\n\n### **Conclusion:**\n\nThus, the appropriate relational expression for buffer size $L$ is:\n\n**d)** $L \\geq (S - R) \\times T$\n\nThis means the buffer size must accommodate the excess data sent by the send task over the data received by the receive task within the specified time period $T$."
  },
  {
    "id": "2019S_FE_AM_19",
    "question": "On a virtual memory computer, the number of pages that can be allocated to the real memory is three (3), and the two (2) algorithms of FIFO and LRU are used for selecting the page to be removed. When a page reference string shown below accesses the three (3) pages, which of the following is an appropriate combination of the number of page replacement operations? Here, the three (3) pages are initially empty and filling of an empty page is not considered as a page replacement operation.\n\n\t1, 3, 2, 1, 4, 5, 2, 3, 4, 5\n\n![Image](Files/Pasted%20image%2020241020141213.png)",
    "options": [
      "$L<(R-S)\\times T$",
      "$L<(S-R)\\times T$",
      "$L\\geq(R-S)\\times T$",
      "$L\\geq(S-R)\\times T$"
    ],
    "correctAnswer": 1,
    "solution": "## **Explanation:**\n\nTo determine the number of **page replacement operations** for both **FIFO** (First-In-First-Out) and **LRU** (Least Recently Used) algorithms, let's go step by step through the **page reference string**:\n\n**Page reference string**: `1, 3, 2, 1, 4, 5, 2, 3, 4, 5`\n\n### Given:\n\n- The number of pages that can be allocated to real memory is **3**.\n- Initially, the memory is empty, so the first three accesses are just page fills, not page replacements.\n- We need to calculate the number of page replacements using both **FIFO** and **LRU**.\n\n### FIFO (First-In-First-Out)\n\n1. **1**: (Page fill, memory: `[1]`)\n2. **3**: (Page fill, memory: `[1, 3]`)\n3. **2**: (Page fill, memory: `[1, 3, 2]`)\n4. **1**: (Page hit, no replacement, memory: `[1, 3, 2]`)\n5. **4**: (Page replacement, replace `1`, memory: `[4, 3, 2]`)\n6. **5**: (Page replacement, replace `3`, memory: `[4, 5, 2]`)\n7. **2**: (Page hit, no replacement, memory: `[4, 5, 2]`)\n8. **3**: (Page replacement, replace `2`, memory: `[4, 5, 3]`)\n9. **4**: (Page hit, no replacement, memory: `[4, 5, 3]`)\n10. **5**: (Page hit, no replacement, memory: `[4, 5, 3]`)\n\n- **Total page replacements (FIFO)**: **3**\n\n### LRU (Least Recently Used)\n\n1. **1**: (Page fill, memory: `[1]`)\n2. **3**: (Page fill, memory: `[1, 3]`)\n3. **2**: (Page fill, memory: `[1, 3, 2]`)\n4. **1**: (Page hit, memory: `[1, 3, 2]`)\n5. **4**: (Page replacement, replace `3` (least recently used), memory: `[1, 4, 2]`)\n6. **5**: (Page replacement, replace `2` (least recently used), memory: `[1, 4, 5]`)\n7. **2**: (Page replacement, replace `1` (least recently used), memory: `[2, 4, 5]`)\n8. **3**: (Page replacement, replace `4` (least recently used), memory: `[2, 3, 5]`)\n9. **4**: (Page replacement, replace `5`, memory: `[2, 3, 4]`)\n10. **5**: (Page replacement, replace `2`, memory: `[5, 3, 4]`)\n\n- **Total page replacements (LRU)**: **6**\n\n### **Conclusion:**\n\nThe correct combination is:\n\n**b)** **FIFO = 3, LRU = 6**"
  },
  {
    "id": "2019S_FE_AM_20",
    "question": "A real-time OS performs preemptive scheduling on a priority basis and schedules two (2) tasks A and B. When A has a higher priority than B, which of the following is an appropriate task management by the real-time OS?",
    "options": [
      "When A is launched during the execution of B, B is assigned a 'ready' status and A is executed.",
      "When A is launched during the execution of B, B is assigned a 'waiting' status and A is executed.",
      "When B is launched during the execution of A, A is assigned a 'ready' status and B is executed.",
      "When B is launched during the execution of A, A is assigned a 'waiting' status and B is executed."
    ],
    "correctAnswer": 0,
    "solution": "## **Explanation:**\n\nIn a **preemptive scheduling** system, tasks with **higher priority** can interrupt or 'preempt' the execution of lower-priority tasks. Here’s the breakdown:\n\n- **Task A** has **higher priority** than Task B.\n- If **Task A is launched while Task B is executing**, the **real-time OS** will **pause** Task B, assigning it to a **'ready' status**.\n- The system will then immediately switch to executing the **higher-priority Task A**.\n- Once Task A is done, Task B can resume execution from where it was paused.\n\n### Other Options:\n\n- **b)** Incorrect: B should be assigned a **'ready' status**, not a **'waiting' status**. A **waiting status** is typically used when a task is waiting for an event or resource.\n- **c)** Incorrect: Task B, being of **lower priority**, should not preempt Task A. Instead, Task A continues execution.\n- **d)** Incorrect: Similar to c, Task A would not enter a **waiting status** for Task B, as A has a higher priority.\n\nIn **preemptive scheduling**, the higher-priority task always preempts the lower-priority one. Therefore, the answer is **a)**."
  }
]